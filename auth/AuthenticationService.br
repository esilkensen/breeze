{

module AuthenticationService
interface Label => (Unit => Unit) =>
{:
  // Given a username, password, and salt, create and store a tuple of the
  // salt, a salted hash of the password, and a PrinRecordC for the user.
  addUser : String => String => String => Unit;

  // Alpha = Bool, but to check this is an IFC violation.
  local Cont = Alpha => (Alpha => OptOf PrinRecordC) => OptOf PrinRecordC;

  // Given a username and password, check whether the password is correct,
  // and if so, return the user's corresponding PrinRecordC.
  authenticate :  String => String => Cont => OptOf PrinRecordC;
:}
implementation \loginLabel setLoginClrPc =>
{|
  Map = (import Map) Str.compare;
  open import Util { andPrin declassify endorse };

  db = {
    setLoginClrPc ();
    ref loginLabel Map.empty
  }@loginLabel;

  // A very bad hash function.
  fun hash {password:String} {salt:String} : String = {
    // Convert string to integer in Z999991/Z (using Horner's Rule).
    rec fun convert {s:String} {acc:Int} : Int = {
      d = Str.decompose s;
      if d.empty then acc
      else convert d.rest (((Str.ord d.char) + 10 * acc) `mod` 999991)
    };
    Str.stringOfHEX (convert (Str.concat salt password) 0)
  };

  fun addUser username password salt = {
    ignore {
      setLoginClrPc ();
      u = newPrin username;
      h = hash password salt;
      // add U to secrecy and integrity: <L, L> ==> <L /\ U, L /\ U>
      lab = (labelOf password `join` labelOf salt) `andPrin` u.prin;
      db := Map.add username (salt@lab, h@lab, u) (!db);
    }@loginLabel;
  };

  fun authenticate username password cL = {
    case (Map.find username (!db)) of {
      | `Some (salt, h, u) => {
          hashLab = labelOf password `join` labelOf salt;
          isCorrect = {
            raiseClrAndPcTo u.clrAuth hashLab;
            h == (hash password salt)
          }@hashLab;
          v = endorse u.pcAuth isCorrect u.prin;
          cL v (\v' => if (declassify u.pcAuth v' u.prin)
                       then `Some u else `None)
        }
      | `None => `None
    };
  };
|}

}
