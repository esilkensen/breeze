{

// This module implements the User Authentication example from Section
// 5.2 of Disjunction Category Labels (Stefan et al. Nordsec '11).

module UserAuthentication
interface
{:
  // A DC label <L, L> where L is a principal for the login client.
  loginLabel : Label;

  // Set the clearance and pc to loginLabel.
  setLoginClrPc : Unit => Unit;

  // Given a username and password, attempt to authenticate the user
  // and return an OptOf PrinRecordC labeled with loginLabel. If the
  // authentication is successful, the pcAuth and clrAuth fields of
  // the PrinRecordC will contain the (nonempty) granted authority.
  login : String => String => (labeled loginLabel);

  // Given a username, password, and salt, create and store a
  // corresponding record in the database.
  register : String => String => String => Unit;
:}
tests
{
  open UserAuthentication { loginLabel setLoginClrPc login register };

  fun testLogin {username:String} {password:String} {success:Bool} = {
    result = {
      setLoginClrPc ();
      case (login username password) of {
        | `Some {| pcAuth=pcAuth; clrAuth=clrAuth |} =>
            (pcAuth <> emptyAuth) && (clrAuth <> emptyAuth)
        | `None => false
      }
    }@loginLabel;
    test result ==> success@loginLabel;
  };

  register "Iron Man"     "I fear rust!"      "908CA";
  register "Breeze Rider" "Blows my mind..."  "56F2E";
  register "Haskell Fan"  "Gosh, I'm so lazy" "D6830";

  testLogin "Iron Man"     "I fear rust!"       true;
  testLogin "Breeze Rider" "Blows my mind..."   true;
  testLogin "Haskell Fan"  "Gosh, I'm so lazy"  true;
  testLogin "Iron Man"     "I don't fear rust!" false;
  testLogin "The Dude"     ""                   false;
}
implementation
{|
  open import LabelUtil {
    changeIntegrityTo;
    changeSecrecyTo;
    isLabeledWithSecrecy;
    isLabeledWithIntegrity;
    changeClrPcWith;
  };

  // A very bad hash function.
  fun hash {password:String} {salt:String} : String = {
    rec fun convert {s:String} {acc:Int} : Int = {
      d = Str.decompose s;
      if d.empty then acc
      else convert d.rest (((Str.ord d.char) + 10 * acc) `mod` 999991)
    };
    Str.stringOfHEX (convert (Str.concat salt password) 0)
  };

// TODO -------------------------------------------------------------

// The login principal and authorities
let {| prin = loginP; clrAuth = loginClr; pcAuth = loginPc |} = newPrin "login";

// The login label.
loginLabel = fullLabel [[loginP]] [[loginP]];

fun setLoginClrPc () : Unit = {
  changeClrPcWith (loginPc `with` loginClr) loginLabel;
};

// Database of logins, salts, hashes.
DB = {|
  Map = (import Map) Str.compare;

  // The reference that holds the database.
  local db = {
    setLoginClrPc (); // necessary to create the reference
    ref loginLabel Map.empty
  } @ loginLabel;

  local fun makeUserRecord username password salt = {
    userRecord = newPrin username;
    lab = {
      userAndLogin = [[userRecord.prin], [loginP]];
      fullLabel userAndLogin userAndLogin
    };
    (salt @ lab, (hash password salt) @ lab, userRecord);
  };

  fun register username password salt = {
    _ = {
      setLoginClrPc ();
      userRecord = makeUserRecord username password salt;
      db := Map.add username userRecord (!db);
    }@loginLabel;
    // We ignore the result, which is always ()@loginLabel, and return
    // a non labeled ().
    ()
  };

  fun lookup {username : String} = {
    Map.find username (!db)
  };
|};

// The authentication service (A_U in the original example).
fun AuthenticationService username password cL =
  case DB.lookup username of {
  | `Some (s, h, userPrinRec) => {
      userP = userPrinRec.prin;
      userClr = userPrinRec.clrAuth;
      userPc = userPrinRec.pcAuth;
      fun setUserClrPc () =
        changeClrPcWith (userPc `with` userClr) (fullLabel [[userP]] [[userP]]);

      // Cheking credentials.
      hashLabel = fullLabel [[loginP], [userP]] [[loginP]];
      isCorrect = {
        raiseClrAndPcBy userClr (secrecyLabelForJoin [[userP]]);
        h == (hash password s)
      }@hashLabel;

      // Endorsing credential test.
      v = changeIntegrityTo userPc isCorrect [[userP], [loginP]];

      // Closure with the user's privilege that declassifies data.
      fun cAU v = {
        // Verifies that u logged in successfully.
        fun vU () = (v `isLabeledWithIntegrity` [[userP], [loginP]]) && v;

        finalLabel = fullLabel [[userP], [loginP]] [];
        res = {
          setUserClrPc ();
          if vU ()
          then `Some userPrinRec
          else `None
        } @ finalLabel;
        changeSecrecyTo userPc res [[loginP]];
      };

      { raiseClrBy userClr (secrecyLabelForJoin [[userP]]);
        cL userP v cAU
      } @ loginLabel;
    }
  | `None => `None
};

// The login service (L in the original example).
fun login username password = {

  fun cL userP v cAU = {

    fun dL () = {
    // Declassifies v to secrecy label [[u]] (leaves integrity unchanged).
      test labelOf v ==>
        fullLabel [[userP], [loginP]] [[userP], [loginP]];
      v' = changeSecrecyTo loginPc v [[userP]];
      // Now, call cAU on the partially declassified value.
      cAU v' // The privilege of cAU.
    };

    userAuth = dL ();
    if userAuth `isLabeledWithSecrecy` [[loginP]]
    then changeIntegrityTo loginPc userAuth [[loginP]]
    else userAuth
  };

  (AuthenticationService username@loginLabel password@loginLabel
  cL)@loginLabel
};

register = DB.register;

|}

}
