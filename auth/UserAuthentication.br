{

// This module implements the User Authentication example from Section
// 5.2 of Disjunction Category Labels (Stefan et al. Nordsec '11).

module UserAuthentication
interface
{:
  // A DC label <L, L> where L is a principal for the login client.
  loginLabel : Label;

  // Set the clearance and pc to loginLabel.
  setLoginClrPc : Unit => Unit;

  // Given a username and password, attempt to authenticate the user
  // and return an OptOf PrinRecordC labeled with loginLabel. If the
  // authentication is successful, the pcAuth and clrAuth fields of
  // the PrinRecordC will contain the (nonempty) granted authority.
  login : String => String => (labeled loginLabel);

  // Given a username, password, and salt, create and store a
  // corresponding record in the database.
  register : String => String => String => Unit;
:}
tests
{
  open UserAuthentication { loginLabel setLoginClrPc login register };

  fun testLogin {username:String} {password:String} {success:Bool} = {
    result = {
      setLoginClrPc ();
      case (login username password) of {
        | `Some {| pcAuth=pcAuth; clrAuth=clrAuth |} =>
            (pcAuth <> emptyAuth) && (clrAuth <> emptyAuth)
        | `None => false
      }
    }@loginLabel;
    test result ==> success@loginLabel;
  };

  register "Iron Man"     "I fear rust!"      "908CA";
  register "Breeze Rider" "Blows my mind..."  "56F2E";
  register "Haskell Fan"  "Gosh, I'm so lazy" "D6830";

  testLogin "Iron Man"     "I fear rust!"       true;
  testLogin "Breeze Rider" "Blows my mind..."   true;
  testLogin "Haskell Fan"  "Gosh, I'm so lazy"  true;
  testLogin "Iron Man"     "I don't fear rust!" false;
  testLogin "The Dude"     ""                   false;
}
implementation
{|
  Map = (import Map) Str.compare;

  open import LabelUtil {
    hasSecrecy hasIntegrity changeSecrecyTo changeIntegrityTo
    changeClrPcWith
  };

  l = newPrin "login";

  loginLabel = fullLabel [[l.prin]] [[l.prin]];

  fun setLoginClrPc _ = {
    changeClrPcWith (l.pcAuth `with` l.clrAuth) loginLabel
  };

  // A very bad hash function.
  fun hash {password:String} {salt:String} : String = {
    rec fun convert {s:String} {acc:Int} : Int = {
      d = Str.decompose s;
      if d.empty then acc
      else convert d.rest (((Str.ord d.char) + 10 * acc) `mod` 999991)
    };
    Str.stringOfHEX (convert (Str.concat salt password) 0)
  };

  // The reference to store salts, hashes, and user PrinRecordC's.
  db = {
    setLoginClrPc ();
    ref loginLabel Map.empty
  }@loginLabel;

  fun register username password salt = {
    ignore {
      setLoginClrPc ();
      u = newPrin username;
      lab = fullLabel [[u.prin], [l.prin]] [[u.prin], [l.prin]];
      userRecord = (salt@lab, (hash password salt)@lab, u);
      db := Map.add username userRecord (!db)
    }@loginLabel;
  };

  fun lookup {username:String} = {
    Map.find username (!db)
  };

  fun login username password = {
    fun cL userP v cAU = {
      fun dL () = {
        // Declassifies v to secrecy label [[u]] (leaves integrity unchanged).
        test labelOf v ==>
          fullLabel [[userP], [l.prin]] [[userP], [l.prin]];
        v' = changeSecrecyTo l.pcAuth v [[userP]];
        // Now, call cAU on the partially declassified value.
        cAU v' // The privilege of cAU.
      };

      userAuth = dL ();
      if userAuth `hasSecrecy` [[l.prin]]
      then changeIntegrityTo l.pcAuth userAuth [[l.prin]]
      else userAuth
    };

    case lookup username of {
      | `Some (s, h, u) => {
          fun setUserClrPc () = {
            changeClrPcWith (u.pcAuth `with` u.clrAuth)
                            (fullLabel [[u.prin]] [[u.prin]])
          };

          // Cheking credentials.
          hashLabel = fullLabel [[l.prin], [u.prin]] [[l.prin]];
          correct = {
	    raiseClrAndPcBy u.clrAuth (fullLabel [[u.prin]] [[]]);
            h == (hash password s)
          }@hashLabel;

          // Endorsing credential test.
          v = changeIntegrityTo u.pcAuth correct [[u.prin], [l.prin]];

          // Closure with the user's privilege that declassifies data.
          fun cAU v = {
            // Verifies that u logged in successfully.
            fun vU () = (v `hasIntegrity` [[u.prin], [l.prin]]) && v;

            finalLabel = fullLabel [[u.prin], [l.prin]] [];
            res = {
              setUserClrPc ();
              if vU () then `Some u else `None
            }@finalLabel;
            changeSecrecyTo u.pcAuth res [[l.prin]];
          };

          { raiseClrBy u.clrAuth (secrecyLabelForJoin [[u.prin]]);
            cL u.prin v cAU
          }@loginLabel;
        }
      | `None => `None
    }
  }@loginLabel;

|}

}
