{

// This module implements the User Authentication example from Section
// 5.2 of Disjunction Category Labels (Stefan et al. Nordsec '11).

module UserAuthentication
interface
{:
  // A DC label <L, L> where L is a principal for the login client.
  loginLabel : Label;

  // Set the clearance/pc = <S, I> to <S /\ L, I /\ L>.
  setLoginClrPc : Unit => Unit;

  // Given a username and password, attempt to authenticate the user
  // and return an OptOf PrinRecordC labeled with loginLabel. If the
  // authentication is successful, the pcAuth and clrAuth fields of
  // the PrinRecordC will contain the (nonempty) granted authority.
  login : String => String => (labeled loginLabel);

  // Given a username, password, and salt, create and store a
  // corresponding record in the database.
  register : String => String => String => Unit;
:}
tests
{
  open UserAuthentication { loginLabel setLoginClrPc login register };

  fun testLogin {username:String} {password:String} {success:Bool} = {
    result = {
      setLoginClrPc ();
      case login username password of {
        | `Some {| pcAuth=pcAuth; clrAuth=clrAuth |} =>
            (pcAuth <> emptyAuth) && (clrAuth <> emptyAuth)
        | `None => false
      }
    }@loginLabel;
    test result ==> success@loginLabel;
  };

  register "Iron Man"     "I fear rust!"      "908CA";
  register "Breeze Rider" "Blows my mind..."  "56F2E";
  register "Haskell Fan"  "Gosh, I'm so lazy" "D6830";

  testLogin "Iron Man"     "I fear rust!"       true;
  testLogin "Breeze Rider" "Blows my mind..."   true;
  testLogin "Haskell Fan"  "Gosh, I'm so lazy"  true;
  testLogin "Iron Man"     "I don't fear rust!" false;
  testLogin "The Dude"     ""                   false;
}
implementation
{|
  Map = (import Map) Str.compare;

  open import LabelUtil {
    hasSecrecy hasIntegrity changeSecrecyTo changeIntegrityTo
    changeClrPcWith
  };

  fun hash {password:String} {salt:String} : String = {
    rec fun convert {s:String} {acc:Int} : Int = {
      d = Str.decompose s;
      if d.empty then acc
      else convert d.rest (((Str.ord d.char) + 10 * acc) `mod` 999991)
    };
    Str.stringOfHEX (convert (Str.concat salt password) 0)
  };

  l = newPrin "login";

  loginLabel = fullLabel [[l.prin]] [[l.prin]];

  fun setLoginClrPc _ = {
    changeClrPcWith (l.pcAuth `with` l.clrAuth) loginLabel;
  };

  db = {
    setLoginClrPc ();
    ref loginLabel Map.empty
  }@loginLabel;

  fun register username password salt = {
    ignore {
      setLoginClrPc ();
      u = newPrin username;
      lab = fullLabel [[l.prin], [u.prin]] [[l.prin], [u.prin]];
      userRecord = (salt@lab, (hash password salt)@lab, u);
      db := Map.add username userRecord (!db);
    }@loginLabel;
  };

  fun login username password = {
    case Map.find username (!db) of {
      | `Some (s, h, u) => {
          // Set the clearance/pc = <S, I> to <S /\ U, I /\ U>.
          fun setUserClrPc _ = {
            changeClrPcWith (u.pcAuth `with` u.clrAuth)
                            (fullLabel [[u.prin]] [[u.prin]]);
          };

	  hashLabel = labelOf h;
          v = {
	    setUserClrPc ();
            h == (hash password s)
          }@hashLabel;

          { 
            raiseClrBy u.clrAuth (secrecyLabelForJoin [[u.prin]]);
            v' = changeSecrecyTo l.pcAuth v [[u.prin]];
	    finalLabel = fullLabel [[u.prin], [l.prin]] [];
	    res = {
              setUserClrPc ();
	      if (v' `hasIntegrity` [[u.prin], [l.prin]]) && v
	      then `Some u else `None
	    }@finalLabel;
	    userAuth = changeSecrecyTo u.pcAuth res [[l.prin]];
            if userAuth `hasSecrecy` [[l.prin]]
            then changeIntegrityTo l.pcAuth userAuth [[l.prin]]
            else userAuth
          }@loginLabel;
        }
      | `None => `None@loginLabel
    }
  };

|}

}
