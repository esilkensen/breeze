{

open import AsciiArt { (@=) (@<=) };

// This module implements User Authentication example from Section 5.2
// in Disjunction Category Labels (Stefan et al. Nordsec '11).
// http://www.scs.stanford.edu/~deian/pubs//stefan:2011:dclabels.pdf

module LoginClient
interface
{:
  // A DC label <L, L> where L is a principal for the login client.
  loginLabel : Label;
  
  // Update both the pc and clearance by raising the secrecy and lowering
  // the integrity by the login principal L. For example, if <S, I> is the
  // current pc/clearance, then the pc/clearance becomes <S /\ L, I /\ L>.
  setLoginClrPc : Unit => Unit;

  // Given a username, password, and salt, create a corresponding record
  // and store it in the database.
  register : String => String => String => Unit;

  // Given a username and password, attempt to authenticate the user and
  // return an OptOf PrinRecordC labeled with the login client's label.
  // The return value is `None when the username is invalid; if the login
  // is successful, then the clrAuth and pcAuth fields of the PrinRecordC
  // represent the user's (nonempty) granted authority.
  login : String => String => ((OptOf PrinRecordC)@=loginLabel);
:}
tests
{
  open LoginClient { loginLabel setLoginClrPc register login };

  fun testLogin {username:String} {password:String} {success:Bool} = {
    result = {
      setLoginClrPc ();
      case login username password of {
        | `Some u => (u.pcAuth <> emptyAuth) && (u.clrAuth <> emptyAuth)
        | `None => false
      }
    }@loginLabel;
    test result ==> success@loginLabel;
  };
  
  register "Iron Man"     "I fear rust!"      "908CA";
  register "Breeze Rider" "Blows my mind..."  "56F2E";
  register "Haskell Fan"  "Gosh, I'm so lazy" "D6830";

  testLogin "Iron Man"     "I fear rust!"       true;
  testLogin "Breeze Rider" "Blows my mind..."   true;
  testLogin "Haskell Fan"  "Gosh, I'm so lazy"  true;
  testLogin "Iron Man"     "I don't fear rust!" false; // bad password
  testLogin "The Dude"     ""                   false; // bad username
}
implementation
{|
  Map = (import Map) Str.compare;

  open import Util { declassify };
  open import AuthenticationService { makeUserRecord authenticate };

  l = newPrin "L";

  loginLabel = fullLabel [[l.prin]] [[l.prin]];

  fun setLoginClrPc _ = {
    auth = l.pcAuth `with` l.clrAuth;
    raiseClrAndPcBy auth (loginLabel `meet` topBottom);
    setPc auth (getPc () `meet` (loginLabel `join` topBottom));
    lowerClrTo (getClr () `meet` (loginLabel `join` topBottom));
  };

  db = {
    setLoginClrPc ();
    ref loginLabel Map.empty
  }@loginLabel;

  fun register username password salt = {
    ignore {
      setLoginClrPc ();
      usr = makeUserRecord username password@loginLabel salt@loginLabel;
      db := Map.add username usr (!db);
    }@loginLabel;
  };

  fun login username password = {
    fun cL v {cAU:Alpha => (Alpha@<=loginLabel)} = {
      cAU (declassify l.pcAuth v l.prin)
    };
    setLoginClrPc ();
    case Map.find username (!db) of {
      | `Some usr => authenticate password@loginLabel usr cL
      | `None => `None
    }
  }@loginLabel;
|}

}
