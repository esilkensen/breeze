{

module LabelUtil
interface
{:
  // Return whether the secrecy component of a value's label is equal
  // to the given CNF formula.
  hasSecrecy : Alpha => SeqOf (SeqOf Prin) => Bool;

  // Return whether the integrity component of a value's label is
  // equal to the given CNF formula.
  hasIntegrity : Alpha => SeqOf (SeqOf Prin) => Bool;

  // Set the secrecy component of a value's label to the given CNF
  // formula, and return the relabeled value.
  changeSecrecyTo : Auth => Alpha => SeqOf (SeqOf Prin) => Alpha;

  // Set the integrity component of a value's label to the given CNF
  // formula, and return the relabeled value.
  changeIntegrityTo : Auth => Alpha => SeqOf (SeqOf Prin) => Alpha;

  // Update both the pc and clearance by raising the secrecy and
  // lowering the integrity by the given label. For example, if <S, I>
  // is the current pc/clearance and <S', I'> is the input label, then
  // the pc/clearance is set to <S /\ S', I /\ I'>.
  changeClrPcWith : Auth => Label => Unit;

  andPrin : Label => Prin => Label;
:}
implementation
{|

fun hasSecrecy x cnf = {
  let (s, _) = reifyLabel (labelOf x);
  (secrecyLabel s) == (secrecyLabel cnf)
};

fun hasIntegrity x cnf = {
  let (_, i) = reifyLabel (labelOf x);
  (integrityLabel i) == (integrityLabel cnf)
};

fun changeIntegrityTo auth x cnf = {
  let (s, _) = reifyLabel (labelOf x);
  setLabel auth x (fullLabel s cnf)
};

fun changeSecrecyTo auth x cnf = {
  let (_, i) = reifyLabel (labelOf x);
  setLabel auth x (fullLabel cnf i)
};

fun changeClrPcWith auth lab = {
  raiseClrAndPcBy auth (lab `meet` topBottom);
  setPc auth (getPc () `meet` (lab `join` topBottom));
  lowerClrTo (getClr () `meet` (lab `join` topBottom));
};

fun andPrin lab prin = {
  let (s, _) = reifyLabel (lab `join` secrecyLabel [[prin]]);
  let (_, i) = reifyLabel (lab `meet` integrityLabel [[prin]]);
  fullLabel s i
};

|}

}
