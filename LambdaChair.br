{

open import Str { concat };

module LambdaChair
interface
{:
  // System administrator interface
  addPaper : String => String => Int;
  addUser : String => String => Unit;
  addAssignment : String => Int => Unit;
  addConflict : String => Int => Unit;
  asUser : String => (Unit => Unit) => Unit;

  // Reviewer interface
  findPaper : String => Int;
  readPaper : Int => String;
  //readReview : Int => Unit;
  //appendToReview : Int => String => Unit;
:}
implementation 
{|

ReviewEnt = {:
  paperId    : Int;          // Paper number
  paperTitle : String;       // Paper title
  paper      : RefOf String; // Paper content
  review     : RefOf String; // Notebook
:};

User = {:
  name        : String;    // User name
  password    : String;    // Password
  conflicts   : SeqOf Int; // Conflicting papers
  assignments : SeqOf Int; // Papers assigned to review
:};

reviewEntries = ref public [];
users = ref public [];

paperPrins = ref public [];
reviewPrins = ref public [];

rec fun listRef lst ind = {
  case lst of {
    | `Nil => `None
    | `Cons x xs => if ind == 0 then `Some x else listRef xs (ind - 1)
  }
};

fun newReviewEnt {id:Int} {title:String} {content:String} : ReviewEnt = {
  p = newPrin (concat "P" (stringOfInt id));
  r = newPrin (concat "R" (stringOfInt id));
  paperPrins := (!paperPrins) ++ [p];
  reviewPrins := (!reviewPrins) ++ [r];
  paper = ref (fullLabel [] [[p.prin]]) content;
  review = ref (fullLabel [[r.prin]] [[r.prin]]) "";
  {| paperId = id; paperTitle = title; paper = content; review = review; |}
};

fun newUser {name:String} {password:String} : User = {
  {| name = name; password = password; conflicts = []; assignments = [] |}
};

rec fun findUser {name:String} {users:SeqOf User} : OptOf User = {
  case users of {
    | `Nil => `None
    | `Cons u us => if u.name == name
                    then `Some u
                    else findUser name us
  }
};

rec fun findReview {id:Int} {reviews:SeqOf ReviewEnt} : OptOf ReviewEnt = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paperId == id
                    then `Some r
		    else findReview id rs
  }
};

rec fun findPaperId {title:String} {reviews:SeqOf ReviewEnt} : OptOf Int = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paperTitle == title
                    then `Some r.paperId
		    else findPaperId title rs
  }
};

rec fun replaceUser {user:User} {users:SeqOf User} : SeqOf User = {
  case users of {
    | `Nil => `Nil
    | `Cons u us => if u.name == user.name
                    then user :: users
		    else u :: (replaceUser user us)
  }
};

fun getAssignments {name:String} : SeqOf Int = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.assignments
  }
};

fun getConflicts {name:String} : SeqOf Int = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.conflicts
  }
};

// Create a new review entry for a paper and return its id.
fun addPaper {title:String} {content:String} : Int = {
  id = 1 + length (!reviewEntries);
  ent = newReviewEnt id title content;
  reviewEntries := ent :: (!reviewEntries);
  id
};

// Create a new user entry for a given name and password.
fun addUser {name:String} {password:String} : Unit = {
  case (findUser name (!users)) of {
    | `None => users := (newUser name password) :: (!users)
    | `Some u => mkNav "User already exists"
  }
};

// Assign a user to review a paper.  The user must not already be in
// conflict with the paper.
fun addAssignment {name:String} {id:Int} : Unit = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.conflicts)
                 then mkNav "User in conflict with paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = u.conflicts;
                                   assignments = id :: u.assignments
                                 |} (!users)
  }
};

// Mark a user as being in conflict with a paper.  The user must not
// already be assigned to the paper.
fun addConflict {name:String} {id:Int} : Unit = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.assignments)
                 then mkNav "User assigned to paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = id :: u.conflicts;
                                   assignments = u.assignments
                                 |} (!users)
  }
};

// Execute code with the current pc set to (True, R1 /\ ... /\ Rn)
// where R1 ... Rn are the principals corresponding corresponding to
// the review entries for each paper the user is assigned to review.
fun asUser {name:String} {mainReview:Unit => Unit} : Unit = {
  rs = map (\id => case listRef (!reviewPrins) (id - 1) of {
                     | `Some r => r
                   })
           (sort (\x y => x < y) (getAssignments name));
  userPc = fullLabel [] (map (\r => [r.prin]) rs);
  pc = getPc ();
  lowerPcTo (foldl with emptyAuth (map (\r => r.pcAuth) rs)) userPc;
  mainReview ();
  raisePcTo pc;
};

// Return the id of the given paper. 
fun findPaper {title:String} : Int = {
  {
    raisePcTo public;
    case (findPaperId title (!reviewEntries)) of {
      | `None => mkNav "Paper not found"
      | `Some id => id
    }
  }@public
};

// Read and return the content of a paper.
fun readPaper {id:Int} : String = {
  // TODO
  ""
};

|}

}
