{

open import Str { concat Printf };

module LambdaChair
interface
{:
  // System administrator interface
  addPaper : String => String => Int;
  addUser : String => String => Unit;
  addAssignment : String => Int => Unit;
  addConflict : String => Int => Unit;
  asUser : String => (Unit => Unit) => Unit;

  // Reviewer interface
  findPaper : String => Int;
  readPaper : Int => String;
  readReview : Int => Unit;
  appendToReview : Int => String => Unit;
:}
implementation 
{|

ReviewEnt = {:
  paperId    : Int;          // Paper number
  paperTitle : String;       // Paper title
  paper      : RefOf String; // Paper content
  review     : RefOf String; // Notebook
:};

User = {:
  name        : String;    // User name
  password    : String;    // Password
  conflicts   : SeqOf Int; // Conflicting papers
  assignments : SeqOf Int; // Papers assigned to review
:};

f = newPrin "False";
bottom' = integrityLabel [[f.prin]];
lowerPcTo f.pcAuth bottom';

reviewEntries = ref bottom' [];
users = ref bottom' [];

paperPrins = ref bottom' [];
reviewPrins = ref bottom' [];

rec fun listRef lst ind = {
  case lst of {
    | `Nil => `None
    | `Cons x xs => if ind == 0 then `Some x else listRef xs (ind - 1)
  }
};

fun newReviewEnt {id:Int} {title:String} {content:String} : ReviewEnt = {
  p = newPrin (concat "P" (stringOfInt id));
  r = newPrin (concat "R" (stringOfInt id));
  paperPrins := (!paperPrins) ++ [p];
  reviewPrins := (!reviewPrins) ++ [r];
  paper = ref (bottom' `join` (fullLabel [] [[p.prin]])) content;
  review = ref (bottom' `join` (fullLabel [[r.prin]] [[r.prin]])) "";
  {| paperId = id; paperTitle = title; paper = paper; review = review; |}
};

fun newUser {name:String} {password:String} : User = {
  {| name = name; password = password; conflicts = []; assignments = [] |}
};

rec fun findUser {name:String} {users:SeqOf User} : OptOf User = {
  case users of {
    | `Nil => `None
    | `Cons u us => if u.name == name
                    then `Some u
                    else findUser name us
  }
};

rec fun findReview {id:Int} {reviews:SeqOf ReviewEnt} : OptOf ReviewEnt = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paperId == id
                    then `Some r
                    else findReview id rs
  }
};

rec fun findPaperId {title:String} {reviews:SeqOf ReviewEnt} : OptOf Int = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paperTitle == title
                    then `Some r.paperId
                    else findPaperId title rs
  }
};

rec fun replaceUser {user:User} {users:SeqOf User} : SeqOf User = {
  case users of {
    | `Nil => `Nil
    | `Cons u us => if u.name == user.name
                    then user :: users
                    else u :: (replaceUser user us)
  }
};

fun getAssignments {name:String} : SeqOf Int = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.assignments
  }
};

fun getConflicts {name:String} : SeqOf Int = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.conflicts
  }
};

// Create a new review entry for a paper and return its id.
fun addPaper {title:String} {content:String} : Int = {
  id = 1 + length (!reviewEntries);
  ent = newReviewEnt id title content;
  reviewEntries := ent :: (!reviewEntries);
  id
};

// Create a new user entry for a given name and password.
fun addUser {name:String} {password:String} : Unit = {
  case (findUser name (!users)) of {
    | `None => users := (newUser name password) :: (!users)
    | `Some u => mkNav "User already exists"
  }
};

// Assign a user to review a paper.  The user must not already be in
// conflict with the paper.
fun addAssignment {name:String} {id:Int} : Unit = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.conflicts)
                 then mkNav "User in conflict with paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = u.conflicts;
                                   assignments = id :: u.assignments
                                 |} (!users)
  }
};

// Mark a user as being in conflict with a paper.  The user must not
// already be assigned to the paper.
fun addConflict {name:String} {id:Int} : Unit = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.assignments)
                 then mkNav "User assigned to paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = id :: u.conflicts;
                                   assignments = u.assignments
                                 |} (!users)
  }
};

// Execute code with the current pc set to (True, R1 /\ ... /\ Rn)
// where R1 ... Rn are the principals corresponding corresponding to
// the review entries for each paper the user is assigned to review.
fun asUser {name:String} {mainReview:Unit => Unit} : Unit = {
  putStr (Printf.sprintf "asUser \"%s\"\n" name);
  rs = map (\id => contents (listRef (!reviewPrins) (id - 1)))
           (sort (\x y => x < y) (getAssignments name));
  userPc = bottom' `join` (fullLabel [] (map (\r => [r.prin]) rs));
  ret = {
    raisePcTo userPc;
    mainReview ()
  }@userPc;
  ()
};

// Return the id of the given paper. 
fun findPaper {title:String} : Int = {
  putStr (Printf.sprintf "findPaper \"%s\"\n" title);
  0
};

// Read (and write to an output channel) the content of a paper.
fun readPaper {id:Int} : String = {
  putStr (Printf.sprintf "readPaper %d\n" id);
  ""
};

// Read (and write to an output channel) the content of a review.
fun readReview {id:Int} : Unit = {
  putStr (Printf.sprintf "readReview %d\n" id);
  ()
};

// Append a review to the notebook for a paper.
fun appendToReview {id:Int} {rev:String} : Unit = {
  putStr (Printf.sprintf "appendToReview %d \"%s\"\n" id rev);
  ()
};

|}

}
