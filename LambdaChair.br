{

open import Str { Printf };
open import LIORef { newLIORef readLIORef writeLIORef labelOfLIORef };

module LambdaChair
interface
{:
  // System administrator interface
  addPaper : String => String => Int;
  addUser : String => String => Unit;
  addAssignment : String => Int => Unit;
  addConflict : String => Int => Unit;
  asUser : String => (Unit => Unit) => Unit;

  // Reviewer interface
  findPaper : String => Int;
  readPaper : Int => Unit;
  readReview : Int => Unit;
  appendToReview : Int => String => Unit;
:}
implementation 
{|

f = newPrin "False";
bottom' = integrityLabel [[f.prin]];
lowerPcTo f.pcAuth bottom';
lowerClrTo bottom';

reviewEntries = ref bottom' [];
users = ref bottom' [];

paperPrins = ref bottom' [];
reviewPrins = ref bottom' [];

rec fun listRef lst ind = {
  case lst of {
    | `Nil => `None
    | `Cons x xs => if ind == 0 then `Some x else listRef xs (ind - 1)
  }
};

fun paperLabel id = {
  case (listRef (!paperPrins) (id - 1)) of {
    | `None => mkNav "Paper not found"
    | `Some p => bottom' `join` (fullLabel [] [[p.prin]])
  }
};

fun reviewLabel id = {
  case (listRef (!reviewPrins) (id - 1)) of {
    | `None => mkNav "Paper not found"
    | `Some r => bottom' `join` (fullLabel [[r.prin]] [[r.prin]])
  }
};

fun newReviewEnt id title content = {
  p = newPrin (Printf.sprintf "P%d" id);
  r = newPrin (Printf.sprintf "R%d" id);
  paperPrins := (!paperPrins) ++ [p];
  reviewPrins := (!reviewPrins) ++ [r];

  // raise clearance to the new "top"
  prins = (!paperPrins) ++ (!reviewPrins);
  auth = foldl with f.clrAuth (map (\l => l.clrAuth) prins);
  clr = (paperLabel id) `join` (reviewLabel id);
  raiseClrTo auth ((getClr ()) `join` clr);

  paper = newLIORef (paperLabel id) content;
  review = newLIORef (reviewLabel id) "";
  {| paperId = id; paperTitle = title; paper = paper; review = review; |};
};

fun newUser name password = {
  {| name = name; password = password; conflicts = []; assignments = [] |}
};

rec fun findUser name users = {
  case users of {
    | `Nil => `None
    | `Cons u us => if u.name == name
                    then `Some u
                    else findUser name us
  }
};

rec fun findReview id reviews = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paperId == id
                    then `Some r
                    else findReview id rs
  }
};

rec fun findPaperId title reviews = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paperTitle == title
                    then `Some r.paperId
                    else findPaperId title rs
  }
};

rec fun replaceUser user users = {
  case users of {
    | `Nil => `Nil
    | `Cons u us => if u.name == user.name
                    then user :: users
                    else u :: (replaceUser user us)
  }
};

fun getAssignments name = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.assignments
  }
};

fun getConflicts name = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.conflicts
  }
};

// Create a new review entry for a paper and return its id.
fun addPaper title content = {
  id = 1 + length (!reviewEntries);
  ent = newReviewEnt id title content;
  reviewEntries := ent :: (!reviewEntries);
  id
};

// Create a new user entry for a given name and password.
fun addUser name password = {
  case (findUser name (!users)) of {
    | `None => users := (newUser name password) :: (!users)
    | `Some u => mkNav "User already exists"
  }
};

// Assign a user to review a paper.  The user must not already be in
// conflict with the paper.
fun addAssignment name id = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.conflicts)
                 then mkNav "User in conflict with paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = u.conflicts;
                                   assignments = id :: u.assignments
                                 |} (!users)
  }
};

// Mark a user as being in conflict with a paper.  The user must not
// already be assigned to the paper.
fun addConflict name id = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.assignments)
                 then mkNav "User assigned to paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = id :: u.conflicts;
                                   assignments = u.assignments
                                 |} (!users)
  }
};

// Execute code with the current pc set to (True, R1 /\ ... /\ Rn)
// where R1 ... Rn are the principals corresponding corresponding to
// the review entries for each paper the user is assigned to review.
fun asUser name mainReview = {
  putStr (Printf.sprintf "asUser \"%s\"\n" name);
  rs = map (\id => contents (listRef (!reviewPrins) (id - 1)))
           (sort (\x y => x < y) (getAssignments name));
  userPc = bottom' `join` (fullLabel [] (map (\r => [r.prin]) rs));
  raisePcTo userPc;
  mainReview ();
  auth = foldl with f.pcAuth (map (\r => r.pcAuth) (!reviewPrins));
  lowerPcTo auth bottom';
};

// Return the id of the given paper. 
fun findPaper title = {
  putStr (Printf.sprintf "findPaper \"%s\"\n" title);
  case (findPaperId title (!reviewEntries)) of {
    | `None => mkNav "Paper not found"
    | `Some id => id
  }
};

// Read a paper.
fun readPaper id = {
  putStr (Printf.sprintf "readPaper %d\n" id);
  case (findReview id (!reviewEntries)) of {
    | `None => mkNav "Paper not found"
    | `Some r => {
        lab = (getPc ()) `join` (labelOfLIORef r.paper);
        s = { readLIORef r.paper }@lab;
        ()
      }
  }
};

// Read a review.
fun readReview id = {
  putStr (Printf.sprintf "readReview %d\n" id);
  case (findReview id (!reviewEntries)) of {
    | `None => mkNav "Review not found"
    | `Some r => {
        s = readLIORef r.review;
	putStr (Printf.sprintf "    review ==> \"%s\"\n" s);
	// TODO: write to labeled output channel
	()
      }
  }
};

// Append a review to the notebook for a paper.
fun appendToReview id rev = {
  putStr (Printf.sprintf "appendToReview %d \"%s\"\n" id rev);
  case (findReview id (!reviewEntries)) of {
    | `None => mkNav "Review not found"
    | `Some r => {
	lab = (getPc ()) `join` (labelOfLIORef r.review);
        s = { readLIORef r.review }@lab;
	writeLIORef r.review (Printf.sprintf "%s|%s" s rev);
      }
  }
};

|}

}
