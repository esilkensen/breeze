{

open import Str { concat };

module LambdaChair
interface
{:
  // System administrator interface
  addPaper : String => Int;
  addUser : String => String => Unit;
  addAssignment : String => Int => Unit;
  addConflict : String => Int => Unit;
  asUser : String => (Unit => Unit) => Unit;

  // Reviewer interface
  findPaper : String => Int;
  //readPaper : Int => String;
  //readReview : Int => Unit;
  //appendToReview : Int => String => Unit;
:}
implementation 
{|

// Private interface ///////////////////////////////////////////////////

ReviewEnt = {:
  paperId : Int;          // Paper number
  paper   : RefOf String; // Paper content
  review  : RefOf String; // Notebook
:};

User = {:
  name        : String;    // User name
  password    : String;    // Password
  conflicts   : SeqOf Int; // Conflicting papers
  assignments : SeqOf Int; // Papers assigned to review
:};

reviewEntries = ref public [];
users = ref public [];

fun newReviewEnt {id:Int} {content:String} : ReviewEnt = {
  p = newPrin (concat "P" (stringOfInt id));
  r = newPrin (concat "R" (stringOfInt id));
  paper = ref (fullLabel [] [[p.prin]]) content;
  review = ref (fullLabel [[r.prin]] [[r.prin]]) "";
  {| paperId = id; paper = paper; review = review; |}
};

fun newUser {name:String} {password:String} : User = {
  {| name = name; password = password; conflicts = []; assignments = [] |}
};

rec fun findUser {name:String} {users:SeqOf User} : OptOf User = {
  case users of {
    | `Nil => `None
    | `Cons u us => if u.name == name
                    then `Some u
                    else findUser name us
  }
};

rec fun findReview {paper:String} {reviews:SeqOf ReviewEnt} : OptOf ReviewEnt = {
  case reviews of {
    | `Nil => `None
    | `Cons r rs => if r.paper == paper
                    then `Some r
		    else findReview paper rs
  }
};

rec fun replaceUser {user:User} {users:SeqOf User} : SeqOf User = {
  case users of {
    | `Nil => `Nil
    | `Cons u us => if u.name == user.name
                    then user :: users
		    else u :: (replaceUser user us)
  }
};

// Public interface ////////////////////////////////////////////////////

// Create a new review entry for a paper and return its id.
fun addPaper {title:String} : Int = {
  id = 1 + length (!reviewEntries);
  ent = newReviewEnt id title;
  reviewEntries := ent :: (!reviewEntries);
  id
};

// Create a new user entry for a given name and password.
fun addUser {name:String} {password:String} : Unit = {
  case (findUser name (!users)) of {
    | `None => users := (newUser name password) :: (!users)
    | `Some u => mkNav "User already exists"
  }
};

// Assign a user to review a paper.  The user must not already be in
// conflict with the paper.
fun addAssignment {name:String} {id:Int} : Unit = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.conflicts)
                 then mkNav "User in conflict with paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = u.conflicts;
                                   assignments = id :: u.assignments
                                 |} (!users)
  }
};

// Mark a user as being in conflict with a paper.  The user must not
// already be assigned to the paper.
fun addConflict {name:String} {id:Int} : Unit = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => if (member (\x => x == id) u.assignments)
                 then mkNav "User assigned to paper"
                 else users := replaceUser {|
                                   name = u.name;
                                   password = u.password;
                                   conflicts = id :: u.conflicts;
                                   assignments = u.assignments
                                 |} (!users)
  }
};

// TODO
fun asUser {name:String} {mainReview:Unit => Unit} : Unit = {
  test name ==> ?;
  ()
};

// Return the id of the given paper. 
fun findPaper {paper:String} : Int = {
  case (findReview paper (!reviewEntries)) of {
    | `None => mkNav "Paper not found"
    | `Some r => r.paperId
  }
};

// Debugging interface:

fun getAssignments {name:String} : SeqOf Int = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.assignments
  }
};

fun getConflicts {name:String} : SeqOf Int = {
  case (findUser name (!users)) of {
    | `None => mkNav "User not found"
    | `Some u => u.conflicts
  }
};

|}

}
